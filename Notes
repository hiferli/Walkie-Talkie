Steps followed:
1. Initial Commit
    Here, we created a basic ReactJS application as well as installed Node.
    Thereafter, the following packages of node were installed:
        -> Express JS
        ->  Mongoose
        -> Nodemon
        -> Socket.IO
        -> B-Crypt
        -> Cors
        -> DotENV

2. A script was created to initiate Nodemon while the server start. Nodemon is a tool that helps develop Node.js based applications by automatically restarting the node application when file changes in the directory are detected. 

3. A database was connected to the Chat Application. We used MongoDB for the same and a MongoDB cluster was made using free AWS hosting. Further, authentication as well as personal IP adresses were added to the database for safety purposes. Finally, the database was connected to the server

4. React Libraries and Dependancies were installed using Yarn. The following packages were installed:
    -> Axios
    -> Styled-Components
    -> React-Router-Dom

5. Changes are created in the React files, so that they can be used as boilerplate codes. Various Predefined Stylings are removed as well as unnessesary files are removed

6. 3 Different Pages are created, which are as follows:
    -> Register
    -> Login
    -> Chat
   These 3 pages are going to form the base of our application

7. We have used Google fonts to add customized styled fonts to out appllication. Alongside, we have also overwritten base CSS for ease of styling with out own styling.

8. Assets of the application were added to the Assets folder. These assets are:
    -> Loader GIF
    -> Logo of the Application
    -> Robot Animation

9. A basic form was created for New User Registration. This includes creating a basic form which asks for the following information:
    -> User Name
    -> Email Address
    -> Password
    
    Moreover, dummy functions were created for form submission and changes done during the form filling, which would be filled later

10. We used the React Styled Components to add Styling to our Register Page

11. All the information added by the user is extracted using useState React Hook. This allows us the get the information of the user as soon as it is typed by the same. This is verified using the React Chrome Extension Tool as well.

12. We creates a function which validates the information added in the registeration page. This includes the following checks:
    -> UserName, Email Address, PassWord and ConfirmPassword are all non-empty elements
    -> Password is not the same as Confirm Password
    -> UserName length is not less than 5 characters
    -> Password length is not less than 8 characters
    -> Password follows the strong password practices (Password Must Contain Atleast 1 SmallCase Character, 1 UpperCase Character, 1 Numeric Character as well as 1 Special Character)

    If any such check is voilated, the function returns a false. If not, then the function returns a true
    Further, API calls are made only if the validation function return a true.

13. A JS file is created which contains all the API paths we're going to need in this project. These API routes are maintained as well as exported to the other files.

14. The handleValidation() function is created, which creates a POST request for the form to transfer the information to store the same in the database. We've used Axiom for performing validation, which  is a simple promise based HTTP client for the browser and node.js. Axios provides a simple to use library in a small package with a very extensible interface.

15. A Database Schema is created for MongoDB Database. The database consists of the following entities:
    -> Username
    -> Email
    -> Password
    -> isAvatarImageSet
    -> AvatarImage
    The data entered in the database would be with respect to this schema created.

16. We use Express JS to handle our Authentication APIs. The API thread is collected from the APIRoutes file, and further is sent to the specified route
    
17. Finally, we perform the POST request on ExpressJS in the UserRoutes file and further the data is inserted in the MongoDB database using the UserController file.

18. Small changes are made in the Schema of the database as well as the version of React-Toastify is changed to a previous version to avoid the useReducer problem.

19. The useController functionality is created, which registers the user into the MongoDB database. Before registering, it checks whether the username or the password is registered with the database or not. If not so, the data entered by the users is registered in the database. A status flag of `true` is sent if the user is registered successfuly and a `false` if there were errors while registering the user.

20. The final changes to the Register Page is done. The status flag sent while registration decides the further steps. If the user is successfully registered, it is further sent to the Chat page. If not, an error toast describing the error is shown on the page. 

21. The Frontend for Login page is created inspired by the Registration Page. The parameters like Email Address as well as Confirm Password are removed along with their validation conditions. Further, the backend for login would be created inspired by the backend of the Registration page.

22. Another Route is created for the Login Functionality in the application, which is redirected to the User Controller File, in which the credentials are first validated and later the user is logged in his account. 

23. Information about already logged in users is extracted from the LocalStorage and if the user had previously logged in the system then they are redirected to the chat page directly. This is a common practice seen in Web-Applications like FaceBook, WhatsApp Web, Instagram and various others.

24. A route for setting up the user avatar is created, which would be used to create an avatar for the users. Alongside, a new page for Setting Up Avatar is created and is added to App.js 

25. The boilerplate code for SetAvatar is created which contains useState Hooks for changing, modifying and creating avatars, which would be taken from the Multiavatar API online.

26. Function is created to set up a new Avatar for the user, which generates random avatars for the users by passing random integers as parameters for random avatar generation. 

27. Frontend to show the created avatar is created, which displays the 4 generated avatar and let the user choose the avatar which they like to.

28. Styling is added the the whole page where the user is given the option to set their avatars from the total of 4 avatars created randomly. This is done using the styled components react libarary.

29. Using the Ternary Operator, we added the method for page loading until the APIs are not loaded with the Avatars. Also, the feature of adding Toast when none of the avatars is selected is also added in the selectedAvatar functions

30. The backend for the SetProfilePicture is created, in which first the route for node has been made and lateron the MongoDB Database is updated with the selected avatar and the flag for the avatar is changed to true.

31. A final functionality is added to avoid redundant users. If a user is not logged in and tries to change their avatar using URLs, then they are redirected to the login page. Moreover, some bugs in the ExpressJS Routing is fixed

32. Finally, the Chat Component is being created. Styling is added the component initially using the Styled-Components Library in React

33. Firstly, we create a way to get contacts on our chat page. For this, we create an API to get the informaion from the MongoDB Database and thereafter load them into the frontend using the "Components.jsx" file created.

34. The Backend for the Contact list is created, in which we get all the IDs of the users exept from the current user (All but not me) and thereafter the following information is gathered about those IDs:
    -> ID
    -> Email Address
    -> Avatar Image
    -> Username

Only a certian amount of information is fetched from the database since the passwords are also stored in the fields of the database. Finally, all this information is sent to the Frontend part (Contacts.jsx) via this API.

35. Firstly, the base condition of the user logged in is checked. If the user is logged in (LocalStorage has Logged In data) then the user's information is used to login the chat page. Else the user is redirected to the login page.

36. The user is checked and thereafter is added to the page. This is done by checking the data of the user. If they have an avatar, theyre set as current user and if not then they're redirected to the setAvatar Page

37. In the contacts page, we're first checking the current user status. If we have the current user logged in, the profile image as well as the username is visible. This is done using the combination of useEffect and useState hooks. 

38. Using the useState and useEffect Hooks as well as using AND check conditioning, we obtain the user information from the backend and thereafter extract that information to show it on the contacts panel on the chat page. 

39. Similar to what we did before, we added the styling to our Contacts Components using Styled Components

40. The Selected User is passed from the Chat Component to the Contacts Component and hence is highlighted when selected. Moreover, a minor bug is fixed which hindered the occurence of other users on any chat window

41. The Selected User is passed as a parameter to the Contacts Componenet and thereafter the selected Contact is highlighted and the chat with that contact would be opened (To be done in the future... Using SocketIO)

42. A Welcome Screen is Created, which would be visible when no user is selected. This is done by making another Component in the Chat file and passing the currentUser as a parameter to the same. 

43. The Welcome Component is created with the GIF file as well as the username. Moreover, styled components is added to the smae

44. The fuctionality to switch between the Welcome Component and the Chat Component is created by making another comonent for the Chat Page and using the Ternary Operator to switch between the 2

45. The Chat Container is Created, which would take the current chat as a parameter and would display the chats between the user and the other person. We used the same ternary operator check to check whether there exists a chat or not.